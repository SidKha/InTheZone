#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Motor,  port2,           arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           arm2,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           arm3,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           arm4,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int armPos = 0;

const int ERR_MTRPWR_RATIO = 5; //how much the motor moves per unit of error
const int MTR_THRESH = 10;
const int MAX_POS = 52;
const int MIN_POS = 0;
const int ARM_POS_CHANGE_RATE = 1000;
const int JOY_THRESH = 10;

int motorPower = 0;

task keepArmStraight(){
  while(true){
    motorPower = (armPos - SensorValue[armPot]) / ERR_MTRPWR_RATIO; // sensorvalue isnt an actual array dont get pranked
    int x = abs(motorPower) > MTR_THRESH ? motorPower : 0;
    motor[arm1] = x; // dont move arm within range of MTR_THRESH
    motor[arm2] = x; 
    motor[arm3] = x; 
    motor[arm4] = x; 
    EndTimeSlice();
  }
}

task main(){
  startTask(keepArmStraight);
  while(true){
    if(abs(vexRT[Ch2]) > JOY_THRESH){ // if input is larger than threshold
      int setArmPos =  armPos + (vexRT[Ch2] / ARM_POS_CHANGE_RATE);
      if(setArmPos < MIN_POS){
        armPos = MIN_POS;
      }
      else if(setArmPos < MAX_POS){
        armPos = setArmPos;
      }
      else armPos = MAX_POS;
    }
    wait1Msec(500);
  }
}
